[回RedRock主目录页](../README.md)

# 简化Redis系统和动态扩展

## Redis + Relational DB系统（关系型数据库）的简化

在我们的实际应用中，很多时候，是用下面的架构去使用Redis

```
                    **********************************            
                    *         Redis client           *
                    *                                *
                    *      读写Redis, Write要TTL      *
                    *    如果miss, 需通过DB恢复数据     *
                    **********************************   



**********************************             ******************************                                  
*        Redis Server            *             *    Relational DB Server    *
*                                *             *                            *
*   大内存, 且需设置Eviction保护    *             *    例如：MySQL, PostgreSQL  *
**********************************             ******************************
```

1. 我们用Redis Server是因为它快，但缺陷是它内存超了会被操作系统杀死
2. 所以，为了保证Redis Server的安全，也包括能获得较新的数据，我们需要写入时给数据带入TTL，过时失效
3. 同时，Redis Server也很可能需要设置Eviction，保证内存不会消耗光
4. 那么被TTL和Eviction删除的Redis数据，需要在另外一个地方存储，就是上面的Relational DB
5. 于是Redis Client还必须增加一个逻辑，就是Redis找不到数据，还必须到DB去找并到Redis里恢复

以上可以看出，Redis Client逻辑比较复杂，整个系统也涉及两类Server，Redis Server和Relational DB Server，我们都要不同的API去处理，还需要不同的管理，开发、管理和相关的硬件的成本都不小。

同时，还有一些潜在的问题去要处理（网上有很多关于这两个问题的讨论，大家可以去搜索一下）：

* 一致性问题：即Redis Server和DB Server存有同一数据，如果修改，可能带来读写的不一致
* 缓存击穿：如果Redis Server万一死掉，Relational DB Server会出现顶不住原来的大负载，导致连锁恶化

假设：我们不用到Relational DB Server的一些功能，比如关系数据结构、事务原子保证等，只是简单的Key/Value数据，那么上面两类Server，更像下面的结合体

```
*********************        ************************
*    Redis Server   *  with  *  支持可写且可查询的磁盘  * 
*********************        ************************
```

这就是一个RedRock，也是RedRock要解决的问题和对应的应用环境。

于是，我们可以简单将上面的系统替换为：

```
******************
*    RedRock     *
****************** 
```

当然，如果你说Redis + Relational DB使数据有更多安全，或者有两个机器从而坚固性HA更高，那么，对应地，RedRock支持RDB/AOF磁盘备份，同时可以使用Redis集群技术（Master/Slave, Sentinel, Redis Cluster），所以RedRock可以达到同样的HA效果。

## 动态扩展

我们有这样的需求，比如：某段时间大促销，或者微博头条出现热点爆料。在短时间内，会产生大量的数据需求，但过了这个高峰期，这些新增的数据就较少访问。

假设平时就是32G的数据足够，但大促销期间，新来最多600G的数据，但过了高峰期（具体多长时间不知道，因为有个长期的衰减），又平复到日常32G的数据。

如果是用Redis Server（假设只用Redis），我们需要为这个最高峰预留足够的内存，就需要准备一个632G内存的超级服务器。

站在热数据的角度考虑，这个需求可以这样分析：大促销或热点爆料期间，热数据最高600G+32=632G。然后随着时间推移（可能几个月），这些600G数据会慢慢变冷（但我们不能删除，因为未来偶尔还可能会被客户提起和使用），又恢复到日常32G热数据的状态，而且，这日常32G热数据，大概率和600G的热点数据不重叠或较少重叠。

那么，你会发现，过了繁忙期，这个超级服务器很浪费。即热数据的规模，可能是动态的。

那么用RedRock如何解决这个动态扩展问题？

* 大促销或热点爆料

在这台632G的超级服务器上，启动一个RedRock进程，设置其热数据额为600G（maxrockmem == 600G）

或者热数据额设置632G, i.e., maxrockmem == 632G，取决于你如何看当日的热数据，即当日热数据是否还包含昨日的32G数据。不过设置为600G也可以兼容632G，详细可参考RedRock的机理，没有任何问题。

* 其后衰退期

定期（比如：每周），减少RedRock的热数据额度32G，i.e., 每周maxrockmem = 上周maxrockmem - 32G。

同时，在同一硬件服务器上，再启动一个RedRock进程，设置其热数据额为32G，可以再提供一个类似的日常服务。

* 最后稳定期

在这个超级硬件服务器上，可以容纳20个RedRock进程，每个都是32G的热数据限额，并提供20个日常服务。

而所有的数据查询和修改（含大促销或热点爆料）继续支持。

具体服务进程的迁移和管理，可以用容器docker技术或者Redis集群技术加以实现，不再详述。

